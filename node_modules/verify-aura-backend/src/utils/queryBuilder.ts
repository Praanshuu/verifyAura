import { SupabaseClient } from '@supabase/supabase-js'; 
import { 
  QueryFilters, 
  SortOptions, 
  PaginationOptions, 
  QueryParams,
  PaginatedResponse,
  QueryError,
  SortableFields
} from '../types';

export class QueryBuilder {
  private supabase: SupabaseClient;
  private sortableFields: SortableFields;

  constructor(supabase: SupabaseClient) {
    this.supabase = supabase;
    this.sortableFields = {
      participants: {
        name: 'name',
        email: 'email',
        certificate_id: 'certificate_id',
        created_at: 'created_at',
        revoked_at: 'revoked_at',
        event_name: 'event_name',
        event_code: 'event_code'
      },
      events: {
        event_name: 'event_name',
        event_code: 'event_code',
        date: 'date',
        created_at: 'created_at',
        participant_count: 'participant_count',
        certificate_count: 'certificate_count'
      },
      logs: {
        action: 'action',
        created_at: 'created_at',
        user_email: 'user_email'
      }
    };
  }

  /**
   * Validate and sanitize query parameters
   */
  private validateQueryParams(
    table: keyof SortableFields,
    filters: QueryFilters,
    sort: SortOptions,
    pagination: PaginationOptions
  ): { isValid: boolean; errors: QueryError[] } {
    const errors: QueryError[] = [];

    // Validate pagination
    if (pagination.page < 1) {
      errors.push({
        code: 'INVALID_PAGINATION',
        message: 'Page must be greater than 0',
        field: 'page',
        value: pagination.page
      });
    }

    if (pagination.limit < 1 || pagination.limit > 1000) {
      errors.push({
        code: 'INVALID_PAGINATION',
        message: 'Limit must be between 1 and 1000',
        field: 'limit',
        value: pagination.limit
      });
    }

    // Validate sort field
    const allowedFields = Object.keys(this.sortableFields[table]);
    if (!allowedFields.includes(sort.field)) {
      errors.push({
        code: 'INVALID_SORT',
        message: `Invalid sort field. Allowed fields: ${allowedFields.join(', ')}`,
        field: 'sort.field',
        value: sort.field
      });
    }

    // Validate sort direction
    if (!['asc', 'desc'].includes(sort.direction)) {
      errors.push({
        code: 'INVALID_SORT',
        message: 'Sort direction must be "asc" or "desc"',
        field: 'sort.direction',
        value: sort.direction
      });
    }

    return { isValid: errors.length === 0, errors };
  }

  /**
   * Execute paginated query for participants
   */
  async queryParticipants(
    filters: QueryFilters,
    sort: SortOptions,
    pagination: PaginationOptions
  ): Promise<PaginatedResponse<any>> {
    const startTime = Date.now();
    
    // Validate parameters
    const validation = this.validateQueryParams('participants', filters, sort, pagination);
    if (!validation.isValid) {
      throw new Error(`Query validation failed: ${validation.errors.map(e => e.message).join(', ')}`);
    }

    try {
      // Build base query with joins
      let query = this.supabase
        .from('participants')
        .select(`
          *,
          events (
            event_name,
            event_code,
            date
          )
        `, { count: 'exact' });

      // Apply filters
      if (filters.search) {
        const searchFilter = this.buildParticipantSearchFilter(filters.search);
        query = query.or(searchFilter);
      }

      if (filters.event_id) {
        query = query.eq('event_id', filters.event_id);
      }

      if (filters.status === 'active') {
        query = query.eq('revoked', false);
      } else if (filters.status === 'revoked') {
        query = query.eq('revoked', true);
      }

      if (filters.date_from) {
        query = query.gte('created_at', filters.date_from);
      }

      if (filters.date_to) {
        query = query.lte('created_at', filters.date_to);
      }

      // Apply sorting - use the actual column name from sortableFields
      // For joined fields, we need to handle them differently
      const sortField = this.sortableFields.participants[sort.field as keyof SortableFields['participants']] || 'created_at';
      
      // Handle special cases for joined fields
      if (sortField === 'event_name' || sortField === 'event_code') {
        // For joined fields, we need to sort by the events table
        query = query.order(`events.${sortField}`, { ascending: sort.direction === 'asc' });
      } else {
        // For regular participant fields, use the column name directly
        query = query.order(sortField, { ascending: sort.direction === 'asc' });
      }

      // Apply pagination
      query = query.range(pagination.offset, pagination.offset + pagination.limit - 1);

      // Execute query
      const { data, error, count } = await query;

      if (error) {
        throw new Error(`Database error: ${error.message}`);
      }

      // Flatten the event data structure
      const flattenedData = (data || []).map((participant: any) => {
        const { events, ...rest } = participant;
        return {
          ...rest,
          event_name: events?.event_name || 'Unknown Event',
          event_code: events?.event_code || 'N/A',
          event_date: events?.date
        };
      });

      const queryTime = Date.now() - startTime;
      const total = count || 0;
      const totalPages = Math.ceil(total / pagination.limit);

      return {
        data: flattenedData,
        pagination: {
          page: pagination.page,
          limit: pagination.limit,
          total,
          totalPages,
          hasNext: pagination.page < totalPages,
          hasPrev: pagination.page > 1
        },
        meta: {
          filters,
          sort,
          queryTime
        }
      };

    } catch (error) {
      throw new Error(`Query execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Build search filter for participants
   */
  private buildParticipantSearchFilter(search: string): string {
    const searchTerms = search.trim().split(/\s+/).filter(term => term.length > 0);
    
    if (searchTerms.length === 0) return '';

    const conditions = searchTerms.map(term => 
      `or(name.ilike.%${term}%,email.ilike.%${term}%,certificate_id.ilike.%${term}%)`
    ).join(',');

    return `(${conditions})`;
  }

  /**
   * Execute paginated query for events with optimized stats calculation
   */
  async queryEvents(
    filters: QueryFilters,
    sort: SortOptions,
    pagination: PaginationOptions
  ): Promise<PaginatedResponse<any>> {
    const startTime = Date.now();
    
    // Validate parameters
    const validation = this.validateQueryParams('events', filters, sort, pagination);
    if (!validation.isValid) {
      throw new Error(`Query validation failed: ${validation.errors.map(e => e.message).join(', ')}`);
    }
  
    try {
      // Build base query for events - use simple select first
      let query = this.supabase
        .from('events')
        .select('*', { count: 'exact' });
  
      // Apply filters
      if (filters.search) {
        const searchFilter = this.buildEventSearchFilter(filters.search);
        query = query.or(searchFilter);
      }
  
      if (filters.tag) {
        query = query.eq('tag', filters.tag);
      }
  
      if (filters.created_by) {
        query = query.eq('created_by', filters.created_by);
      }
  
      if (filters.date_from) {
        query = query.gte('date', filters.date_from);
      }
  
      if (filters.date_to) {
        query = query.lte('date', filters.date_to);
      }
  
      // Apply sorting - use the actual column name from sortableFields
      const sortField = this.sortableFields.events[sort.field as keyof SortableFields['events']] || 'created_at';
      query = query.order(sortField, { ascending: sort.direction === 'asc' });
  
      // Apply pagination
      query = query.range(pagination.offset, pagination.offset + pagination.limit - 1);
  
      // Execute query for events
      const { data, error, count } = await query;
  
      if (error) {
        throw new Error(`Database error: ${error.message}`);
      }
  
      // Get participant counts for each event in a separate query
      const eventsWithStats = await Promise.all(
        (data || []).map(async (event) => {
          try {
            // Get participant count
            const { count: participantCount } = await this.supabase
              .from('participants')
              .select('*', { count: 'exact', head: true })
              .eq('event_id', event.id);
  
            // Get active certificate count (non-revoked)
            const { count: certificateCount } = await this.supabase
              .from('participants')
              .select('*', { count: 'exact', head: true })
              .eq('event_id', event.id)
              .eq('revoked', false);
  
            const today = new Date();
            const eventDate = new Date(event.date);
            let status: 'upcoming' | 'ongoing' | 'ended';
  
            if (eventDate > today) {
              status = 'upcoming';
            } else if (eventDate.toDateString() === today.toDateString()) {
              status = 'ongoing';
            } else {
              status = 'ended';
            }
  
            return {
              ...event,
              participant_count: participantCount || 0,
              certificate_count: certificateCount || 0,
              status
            };
          } catch (error) {
            console.error(`Error getting stats for event ${event.id}:`, error);
            return {
              ...event,
              participant_count: 0,
              certificate_count: 0,
              status: 'unknown'
            };
          }
        })
      );
  
      const queryTime = Date.now() - startTime;
      const total = count || 0;
      const totalPages = Math.ceil(total / pagination.limit);
  
      return {
        data: eventsWithStats,
        pagination: {
          page: pagination.page,
          limit: pagination.limit,
          total,
          totalPages,
          hasNext: pagination.page < totalPages,
          hasPrev: pagination.page > 1
        },
        meta: {
          filters,
          sort,
          queryTime
        }
      };
  
    } catch (error) {
      throw new Error(`Query execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
  
  /**
   * Build search filter for events
   */
  private buildEventSearchFilter(search: string): string {
    const searchTerms = search.trim().split(/\s+/).filter(term => term.length > 0);
    if (searchTerms.length === 0) return '';
    // Build a flat or() filter for all terms and fields
    const conditions: string[] = [];
    for (const term of searchTerms) {
      conditions.push(
        `event_name.ilike.%${term}%`,
        `event_code.ilike.%${term}%`,
        `description.ilike.%${term}%`
      );
    }
    return conditions.join(',');
  }

  /**
   * Execute paginated query for logs
   */
  async queryLogs(
    filters: QueryFilters,
    sort: SortOptions,
    pagination: PaginationOptions
  ): Promise<PaginatedResponse<any>> {
    const startTime = Date.now();
    
    // Validate parameters
    const validation = this.validateQueryParams('logs', filters, sort, pagination);
    if (!validation.isValid) {
      throw new Error(`Query validation failed: ${validation.errors.map(e => e.message).join(', ')}`);
    }

    try {
      // Build base query for logs
      let query = this.supabase
        .from('activity_logs')
        .select('*', { count: 'exact' });

      // Apply filters
      if (filters.search) {
        const searchFilter = this.buildLogSearchFilter(filters.search);
        query = query.or(searchFilter);
      }

      if (filters.date_from) {
        query = query.gte('created_at', filters.date_from);
      }

      if (filters.date_to) {
        query = query.lte('created_at', filters.date_to);
      }

      // Apply sorting - use the actual column name from sortableFields
      const sortField = this.sortableFields.logs[sort.field as keyof SortableFields['logs']] || 'created_at';
      query = query.order(sortField, { ascending: sort.direction === 'asc' });

      // Apply pagination
      query = query.range(pagination.offset, pagination.offset + pagination.limit - 1);

      // Execute query for logs
      const { data, error, count } = await query;

      if (error) {
        throw new Error(`Database error: ${error.message}`);
      }

      const queryTime = Date.now() - startTime;
      const total = count || 0;
      const totalPages = Math.ceil(total / pagination.limit);

      return {
        data: data || [],
        pagination: {
          page: pagination.page,
          limit: pagination.limit,
          total,
          totalPages,
          hasNext: pagination.page < totalPages,
          hasPrev: pagination.page > 1
        },
        meta: {
          filters,
          sort,
          queryTime
        }
      };

    } catch (error) {
      throw new Error(`Query execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Build search filter for logs
   */
  private buildLogSearchFilter(search: string): string {
    const searchTerms = search.trim().split(/\s+/).filter(term => term.length > 0);
    
    if (searchTerms.length === 0) return '';

    const conditions = searchTerms.map(term => 
      `or(action.ilike.%${term}%,user_email.ilike.%${term}%,metadata::text.ilike.%${term}%)`
    ).join(',');

    return `(${conditions})`;
  }
}
